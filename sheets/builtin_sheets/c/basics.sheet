
modifiers:

#
|c|C|
|unsigned|type|signed|signdness|
|keyword|type-qualifier|overflow|
  unsigned integer type variables can hold numbers 2x as big 
  as their signed equivalent, but can't hold negative numbers
  see $|$\|signed\|$$ for opposite
  ! unsigned number going negative causes overflow
  $!$  -1 turns into 4294967295, aka. $$$|$\|UINT_MAX\|$$
   
  $_$range:$$
  see $|$\|limits.h\|$$
    $syn$$_$unsigned int range:$$
    0 -> $|$\|UINT_MAX\|$$
    0 -> 4294967295
    $syn$$_$signed int range:$$
    $|$\|INT_MIN\|$$ -> $|$\|INT_MAX\|$$
    -2147483648 -> 2147483647

  example: 
    unsigned long long i = 10;
    unsigned int       i = 10;
    unsigned short     i = 10;
    unsigned char      i = 10;

    unsigned i = 10;  // same as unsigned int

    $_$overflow:$$
    unsigned int i = -1;
    printf("i: %u\n", i);
    ->i: 4294967295 
    // using %d casts to signed int
    // but the true value is still
    // 4294967295
    printf("i: %d\n", i);
    ->i: -1 
#
|c|C|
|signed|
|keyword|type|type-qualifier|
  the signed keyword / type qualifier signifies
  that an integer type variable is signed
  and therefore can hold negative numbers
  see $|$\|unsigned\|$$ for opposite

  $_$range:$$
  see $|$\|limits.h\|$$
    $syn$$_$unsigned int range:$$
    0 -> $|$\|UINT_MAX\|$$
    0 -> 4294967295
    $syn$$_$signed int range:$$
    $|$\|INT_MIN\|$$ -> $|$\|INT_MAX\|$$
    -2147483648 -> 2147483647

  example:
    // same thing
    int a = -1;
    signed int a = -1;
#
|c|C|
|const|type|constant|
|keyword|type-qualifier|
  variables marked const cant be modified during runtime
  can be applied to all types and structs
  ~ using const vars can speed up the program
  ~ using const can also prevent you from 
  ~ accidentally changing a value you shouln't
  example:
    const int c = 10;
    int a = c * 2;    // legal
    c = a * 2;        // illegal
#
|c|C|
|extern|
|variable|
|keyword|type-modifier|modifier|
  the extern keyword dictates the following object is defined elsewhere
  this can be used to access a variable in multiple .c files
  ~ all function declarations have a 'hidden' extern in front
  example:
    $_$in header.h$$
    extern int var; // declaring var
    $_$in file_a.c$$
    \#include "header.h"
    int a = 0;  // setting value
    $_$in file_b.c$$
    \#include "header.h"
    printf("%d", var);  // accessing

    // same thing
    $_$in some_header.h$$
    void func();
    extern void func();

#
|c|C|
|restrict|
|keyword|type|type-qualifier|
    the restrict keyword / type qualifier
    tells the compiler that a pointer is unique
    so a function isnt passed two pointers
    to the same memory
    allowing for optimizations
    ~ added in C99
    ~ view memcpy() and memmove() for example

    example:
      void multiply_arrays(int* dest, int* src1, int* src2, int n)
      {
        for(int i = 0; i < n; i++)
        { dest[i] = src1[i]*src2[i]; }
      }
      void multiply_arrays_restrict(int* dest, int* restrict src1, int* restrict src2, int n)
      {
        for(int i = 0; i < n; i++)
        { dest[i] = src1[i]*src2[i]; }
      }

      \#define LEN 5
      int arr0[LEN] = { 1, 2, 3, 4, 5 };
      int arr1[LEN] = { 1, 2, 3, 4, 5 };
      int dest[LEN];

      // using arr0 for both sr1 and src2 so no restrict
      muliply_arrays(dest, arr0, arr0 +2, LEN -2);
      // src1 and src2 are different so we can use restrict
      muliply_arrays_restrict(dest, arr0, arr1, LEN);

?< https://stackoverflow.com/questions/745870/realistic-usage-of-the-c99-restrict-keyword >?
#
|c|C|
|volatile|
|keyword|type|type-qualifier|
    the volatile keyword / type qualifier
    tells the compiler the variable 
    may be changed outside the program
    this may be used for example for hardware registers

    example:
      volatile int i;
      volatile struct s_t s;
      int* p = 0;
      volatile int* vp = p; // OK: adds qualifiers (int to volatile int)
      p = vp;               // Error: discards qualifiers (volatile int to int)
      p = (int*)vp;         // OK: cast

      ar *p = 0;
      // Error: char* and volatile char* are not compatible types
      volatile char **vpp = &p;
      // OK, adds qualifiers (char* to char*volatile)
      char * volatile *pvp = &p; 
      
?< https://en.cppreference.com/w/c/language/volatile >?
#
|c|C|
|static|
|keyword|type|type-qualifier|
  the static keyword / type qualifier
  makes a variable retain its value even if 
  the variables scope ends and a normal variable
  would be removed
  declaring a function static means it is no longer
  globally accesible and can only be called inside 
  the file it is defined

  example:
    void function()
    {
      static int call_count = 0;
      int normal = 0;
      call_count++;
      normal++;
      printf("call_count: %d, normal: %d\n", call_count, normal);
    }
    function();
    ->call_count: 1, normal: 1
    function();
    ->call_count: 2, normal: 1
    function();
    ->call_count: 3, normal: 1

    $_$in file_a.c:$$
    void func() { }
    static void func_static() { }
    func();         // this is fine
    func_static();  // this is fine

    $_$in file_b.c:$$
    func();         // this is fine
    func_static();  // not allowed

  ?< https://www.geeksforgeeks.org/static-variables-in-c/\?ref=lbp >?
  ?< https://www.geeksforgeeks.org/what-are-static-functions-in-c/\?ref=lbp >?
#
|c|C|
|auto|
|keyword|type|type-qualifier|
  the auto keyword / type qualifier is applied
  automatically to all scoped variables
  you can only access these variables inside their $|$\|scope\|$$

  ~ you will probably never have to use this

  example:
    void function()
    {
      // same thing
      int var = 0;
      auto int var = 0;
    }

  ?< https://www.geeksforgeeks.org/storage-classes-in-c/\?ref=lbp >?
#
|c|C|
|register|
|keyword|type|type-qualifier|
  the register keyword / type qualifier tells the
  compiler to put a variable into a register if
  possible, instead of memory

  ~ register variables cant be accessed via pointer
  
  example:
    register int var = 0;
   
  ?< https://www.geeksforgeeks.org/storage-classes-in-c/\?ref=lbp >?
#

data structures:

#
|c|C|
|array|data|type|
    arrays hold multiple variables 
    of the same type in direct succesion in memory
    arrays can be formed out of all variable types and structs
    ~ syntax: type var_name[]
    ~ first element in an array has index 0: array[0]
    example:
      int a[10];  // array of size 10 with undefined content
      int b[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
      printf("%d", b[3]); // access third element in b
        -> 3
#
|c|C|
|struct|structure|data|type|
    structs hold variables like an [array], but
    they can hold different types
    ~ [typedef]
    example:
      // definition
      struct data_t { int a; float b; }
      struct data_t var = { .a = 10, .b = 0.1f };
      int a = var.a;      // access variable in struct
      struct data_t* ptr = &var;
      float b = ptr->b;   // access variable in struct-pointer
#
|c|C|
|union|data|type|
  unions are declared like structs, with multiple
  variables, but their size is only the size of the 
  biggest variable.
  meaning all variables in a union share the same memory

  example:
    union a
    {
      char   c; // size 1 byte
      short  s; // size 2 bytes
      int    i; // size 4 bytes
      double d; // size 8 bytes
    };
    printf("sizeof(a): %d", sizeof(a));
    -> sizeof(a): 8
    because d is the biggest variable at 8 bytes

    union b
    {
      unsigned int i;
      float f;
    };
    union b var;
    var.i = 10;
    var.f now has 10u as its value
    which prob. will not read as a proper float value
    and definitely not as 10.0f
#
|c|C|
|typedef|typedef|syntax|
    add a second name for a symbol
    example:
      // types
      typedef unsigned char u8;
      u8 a = 10;
      // enums
      enum a { A };
      typedef enum { A }b;

      enum a var_a = A;
      b      var_b = A;
      // structs
      struct a { int a; };
      typedef struct { int a; }b;

      struct a var_a = { .a = 0 };
      b        var_t = { .a = 0 };
#

actual types:

#
|c|C|
|void|type|
    used in functions with no return
    void* can point to anything
    ! void* doesn't give any information
    ! about the size/type of the value
    example: 
      void  func() {}
      void* ptr = &var;
#
|c|C|
|bool|boolean|type|
    either true or false
    true: 1, false: 0
    8 bit wide
    ! size of types varies, use sizeof() to test
    ! not included in all versions of c
    ~ include "stdbool.h"
    ~ or [define]/[typedef] bool, true, false
    example:
      bool a = true;
      a = false;
      a = 1;
      a = 0;
      if (a)  {...}
      if (!a) {...} // true->false, false->true
#
|c|C|
|char|type|
    char is a whole number
    signed by default
    8 bit wide
    ! size of types varies, use sizeof() to test
    ~ can use [unsigned] modifier
    example: 
      char  func() {}
      char  val = 10;
      char  val = 'A';
      char* ptr = &val;
#
|c|C|
|short|type|
    short is a whole number
    signed by default
    16 bit wide
    ! size of types varies, use sizeof() to test
    ~ can use [unsigned] modifier
    example: 
      short  func() {}
      short  val = 10;
      short* ptr = &val;
#
|c|C|
|int|type|
    int is a whole number
    signed by default
    abrev. for integer 
    32 bit wide
    ! size of types varies, use sizeof() to test
    ~ can use [unsigned] modifier
    example: 
      int  func() {}
      int  val = 10;
      int* ptr = &val;
#
|c|C|
|long|type|
    long is a whole number
    signed by default
    abrev. for integer 
    32 bit wide
    same as [int]
    ! size of types varies, use sizeof() to test
    ~ can use [unsigned] modifier
    example: 
      long  func() {}
      long  val = 10;
      long* ptr = &val;
#
|c|C|
|long-long|long|type|
    long long is a whole number
    signed by default
    abrev. for integer 
    64 bit wide
    ! size of types varies, use sizeof() to test
    ~ can use [unsigned] modifier
    example: 
      long long  func() {}
      long long  val = 10;
      long long* ptr = &val;
#
|c|C|
|float|type|
    float is a decimal number
    32 bit wide
    ! size of types varies, use sizeof() to test
    ~ literals end in 'f': '1.2f'
    example: 
      float  func() {}
      float  val = 12.345f;
      float* ptr = &val;
#
#
|c|C|
|double|type|
    double is a decimal number
    64 bit wide
    ! size of types varies, use sizeof() to test
    ~ unlike [float] literals dont end in 'f'
    example: 
      double  func() {}
      double  val = 12.345;
      double* ptr = &val;
#

#
|c|C|
|literal|literals|number|numbers|string|
  literals are values types directly into the code

  ~ multiline string, like mutliline macro, has to be directly 
  $~$  followed by newline char '\n', aka. nothing after \ char$$

  example:
    int i = 10;       // normal, decimal integer
    int i = 0b101     // base 2,  binary
    int i = 010;      // base 8,  octal
    int i = 0x1A;     // base 16, hexadecimal
    unsigned int       i = 10u; // unsigned decimal integer
    long long          i = 10l; // long decimal integer
    unsigned long long i = 10ul; // unsigned long decimal integer

    float  f = 10.5f;    // float literal
    float  f = 105E-1L;  // float literal, with exponent
    float  f = 105E-1;   // float literal, with exponent
    float  f = 105e-1L;  // float literal, with exponent
    float  f = 105e-1;   // float literal, with exponent
    double f = 10.5;     // double literal
    double f = 105E-1L;  // double literal, with exponent
    double f = 105E-1;   // double literal, with exponent
    double f = 105e-1L;  // double literal, with exponent
    double f = 105e-1;   // double literal, with exponent
    
    char   c = 'c';     // char literal
    char   c = '\n';    // char literal, escaped char
    char   c = 'u0040'; // char literal, unicode, this is @
    
    char*  s = "hello";  // string literal
    char*  s = "hello"",""world"; // acts as one string "hello, world"
    \#define STR "middle"
    char   s = "start "STR" end"  // acts as one string "start middle end"
    char*  s = "line01 \
                line02";  // multiline string literal
  
#

non-standard:

#
|c|C|
|size_t|type|
|rsize_t|RSIZE_MAX|
    unsigned integer, defined in most standard header files
    32 bit wide when compiling 32bit, unsigned int
    64 bit wide when compiling 64bit, unsigned long long
   
    $_$since C11:$$
    rsize_t is the same as size_t but was added in C11 for 
    the _s safe versions of std functions
    RSIZE_MAX is the upper limit of rsize_t
    RSIZE_MAX is less than the actual max of rsize_t
    but because of negative numbers in unsiged int types
    wrapping around to being large positive numbers
    RSIZE_MAX catches these cases
    
    size_t and rsize_t are defined in many std headers
    f.e.: <string.h>, <stdlib.h>, <stdio.h>

    ! size of types varies, use sizeof() to test
    ~ no different from using an unsigned int directly
    ~ just for clarification of intent, i.e. loops, arrays, etc.
    ~ many standard headers use size_t when numbers cant be neg.
    example: 
      size_t size = sizeof(float);

      // rsize_t safety usage in C11 _s functions:
      // s is now ULONG_MAX: 18446744073709551615 (in 64bit)
      // because the unsigned int wrapped around
      rsize_t s = -1;
      assert(s < RSIZE_MAX);
      -> assert triggers because s is ULONG_MAX
         and RSIZE_MAX is less than ULONG_MAX
#
#
|c|C|
|NULL|null|pointer|
    pointer of value 0, defined in most standard header files
    ! trying to acces a null pointer causes a crash
    ~ NULL is (void*)0
    example: 
     \#ifndef NULL
      \#define NULL (void*)0
     \#endif
     int* ptr = NULL;
     if (ptr \!= NULL) { free(ptr); }
     if (ptr)  { printf("ptr = not null"); }
     if (\!ptr) { printf("ptr = null"); }
#

operators:


#
|c|C|
|pointer|address|sizeof|
|basics|operator|operators|size|
|*|&|
  *:      pointer operator, indicates a type is 
          pointer-type, or dereferences a pointer
          which lets you access the variable pointed to
  &:      gets the address of a variable, aka. the pointer
          to that variable
  sizeof: gets compiled to the size of the given type in bytes

  example:
    int  a = 0;
    int* a_ptr = &a;  // a_ptr holds the address of a

    *a_ptr = 1;  // dereferencig a_ptr to access a 
    printf("a: %d", a);
    -> 1

    // @NOTE: the size of variables depend on the os
    //        32bit os's might have different size 
    //        variables than 64bit os's
    printf("size of char: %d", sizeof(char));
    printf("size of short: %d", sizeof(short));
    printf("size of int: %d", sizeof(int));
    printf("size of long int: %d", sizeof(long int));
    -> size of char: 1
    -> size of short: 2
    -> size of int: 4
    -> size of long int: 8
    printf("size of float: %d", sizeof(float));
    printf("size of double: %d", sizeof(double));
    ->size of float: 4
    ->size of double: 8
    // @NOTE: sizeof returns bytes, aka.
    //        char: 1 byte,  8  bits
    //        int:  4 bytes, 64 bites
    //        etc.
#
|c|C|
|basics|arithmetic-operators|operator|operators|
|+|-|/|*|%|++|--|
|add|addtition|sub|subtract|div|divide|mul|multiply|mod|modulo|
  basic mathematic/arithmetic operators
  +:  addition
  -:  subtraction
  /:  division
  *:  multiplication
  %:  modulo, remainder of integer division
  ++: add 1, same as x = x+1
  --: sub 1, same as x = x+-1

  ~ integer divisons dont produce and get rounded
  ~ ++/-- can be applied before or after the variable
  $~$  before in-/decrements variable and then executes other logic$$
  $~$  after executes logic and then in-/decrements, see example$$

  example:
    a = 1 + 1;       // a = 2
    a = 1 - 1;       // a = 0
    a = 2.0f / 1.0f; // a = 0.5f
    a = 2 * 2;       // a = 4
    a = 5 % 2;       // a = 1, 5 / 2 = 2 remaineder 1
    a = 1;
    a++;             // a = 2
    a--;             // a = 1

    int arr[3] = { 0, 1, 2 }; // arr[0] == 0, arr[1] == 1, etc.
    int i = 0;
    int a = arr[i++];
    printf("a: %d, i: %d\n", a, i);
    -> a: 0, i: 1 // accessed arr with i = 0, then incremented
    i = 0;
    int a = arr[++i];
    printf("a: %d, i: %d\n", a, i);
    -> a: 1, i: 1 // incremented i to i == 1, then accessed arr
#
|c|C|
|basics|operator|boolean|
|comparison|realtional-operator|realtional-operators|
|equal|not-equal|less|less-than-or-equal|greater|greater-than-or-equal|
|==|!=|<|<=|>|>=|
|logical-operator|logical-operators|
|and|or|invert|not|
|&&|!|
  
  all the below operators perform some action
  but dont change values on their own, but can be
  used to set values, explicitly
  they get evaluated as a boolen value true/false
  and can therefore be used to, set values, for 
  if, for, while, etc. statements
  ~ using parenthesis any of these statements can 
  $~$  directly be used like a boolean value$$

  $GREEN$relational operators$$:
    a == b -> equal 
    a \!= b -> not equal
    a <  b -> less than
    a <= b -> less than or equal
    a >  b -> greater than
    a >= b -> greater than or equal
    
  $GREEN$logical operators$$:
    a && b -> logical and
    a \|\| b -> logical or
    \!a     -> logical not
              inverts any boolean value
              be that a variable or a 
              statement that gets evaluated
              as a boolean, sucha as the ones above
  
  example:
    // -- relational operators --
    int a = 5;
    int b = 8;
    bool c;
    c = a == b; // false
    c = a == a; // true
    c = a \!= b; // true
    c = a \!= a; // false
    c = a <  b; // true
    c = a <= b; // false
    c = a >  b; // false
    c = a >= b; // true

    // -- logical operators --
    bool a = true;
    bool b = false;
    c = a && b; // false
    c = c && b; // true
    c = c \|\| b; // false
    c = a \|\| b; // true

    // -- combinig --
    bool a = (1 > 0) \|\| (0 > -1); // true
    bool b = false;
    bool c = (a \|\| b) && (a \!= b \|\| b == false);
    if ( (a \|\| b) && (a \!= b \|\| b == false) ) {}
    for (into = 0; (a \|\| b) && (a \!= b \|\| b == false); ++i) {}
    while ( (a \|\| b) && (a \!= b \|\| b == false) ) {}
    c = (a \|\| b) && (a \!= b \|\| b == false) ? true : (!a == false && b) ? true : false;

    // -- logical not \! --
    bool a = true;
    bool b = \!a;    // b is now false
    a = \!a;         // a is now false
    a = \!a;         // a is now true
    int c = 0;
    c = \!c;         // c is now 1
    
    if (\!a) 
    { printf("a didnt change value, but was evaluated as false"); }
    
    a = true; b = true;
    if (\!(a && b)) { printf("wont execute"); }

    bool func() { return true; }

    if ( func()) { printf("func()"); }
    if (\!func()) { printf("!func()"); }
    
    // a is true so this evals. as \!(true) -> false
    bool d = \!(a \? true : false); 

    -> func()
#
|c|C|
|operator|bitwise-operator|basics|
|bit-shift|shift|bitwise-or|or|bitwise-and|and|
|bit|byte|
|<<|>>|&|
  bit shift
    <<: left sides bits are moved left by number on right side
    >>: left sides bits are moved right by number on right side
  bit wise or, and & not
    &: binary and
    \|: binary or
    ^: binary xor
    \~: binary not

  example:
    unsigned int a = 0b001; // a is now 001
    a >> 1;                 // a is now 010
    a << 1;                 // a is now 001
    
    unsigned int a = 0b0001;
    unsigned int b = 0b1000;
    unsigned int c = a \| b; // 1001
    unsigned int d = c & a; // 0001
    unsigned int e = c ^ a; // 1000
    unsigned int f = ~c;    // 0111

?< https://www.tutorialspoint.com/cprogramming/c_operators.htm >?
#
|c|C|
|operator|bitwise-operator|basics|
|assign|assignment|assignment-operators|bitwise-assignment
|add|addtition|sub|subtract|div|divide|mul|multiply|mod|modulo|
|bit-shift|shift|bitwise-or|or|bitwise-and|and|
|bit|byte|
|+=|-=|*=|/=|%=|<<=|>>=|&=|\|=|^=|

  =:   a = b;   a's value is now b's value
  
  $GREEN$arithmetic operators, see $|$\|arithmetic-operators\|$$:
  +=:  a += b;  is equal to a = a + b
  -=:  a -= b;  is equal to a = a - b
  *=:  a *= b;  is equal to a = a * b
  /=:  a /= b;  is equal to a = a / b
  %=:  a %= b;  is equal to a = a % b
  
  $GREEN$bitwise operators, see $|$\|bitwise-operator\|$$:
  <<=: a <<= b; is equal to a = a << b
  >>=: a >>= b; is equal to a = a >> b
  &=:  a &= b;  is equal to a = a & b
  \|=:  a \|= b;  is equal to a = a \| b
  ^=:  a ^= b;  is equal to a = a ^ b

  example: 
    int a = 10; // assign 10 to a 
    a += 10;    // a: 20
    a -= 10;    // a: 10
    a *= 10;    // a: 100
    a /= 10;    // a: 10
    a %= 4;     // a: 2, 10 / 4 = 2, remainder 2
  
    // also work on non-literal values:
    int b = 5;
    a += b;
    a += func();

    a = 1;
    a <<= 1;    // a: 0b0010
    b = a;
    b >>= 1;    // b: 0b0001
    int c = a;  
    c \|= b;     // c: 0b0011
    c &= a;     // c: 0b0010
    c = a \| b;  // c: 0b0011 
    c ^= a;     // c: 0b0001
#

misc:

#
|c|C|
|bit-flag|flag|bitwise-operator|basics|
|bit|byte|
  set and check certain bits in a number
  make number with bit a set

  see $|$\|bitwise-operator\|$$ for explanation
  of <<, >>, &, \| operators

  example:
  
  make a number with specific bit set:
    1 << 0 0001
    1 << 1 0010
    1 << 2 0100
    1 << 3 1000
    aka. 1<<a == 2^a, 1, 2, 4, 8, ...
  combine numbers with specific bits set:
    unsigned int a = 1 << 0;  // 0001 
    unsigned int b = 1 << 3;  // 1000
    unsigned int c = a \| b;   // 1001
  check if bit is set:
    unsigned int a = 1 << 0;  // 0001 
    unsigned int b = 1 << 3;  // 1000   
    unsigned int c = a \| b;   // 1001
    bool d = a & b;           // false
    bool e = a & c;           // true, 0001 in common
  set specific bit 0:
    unsigned int a = 1 << 0 \| 1 << 3;  // 1001
    a = a &= \~(1 << 0);                // 1000

  macros:
    \#define FLAG(a)            (1 << (a))
    \#define HAS_FLAG(a, b)     ((a) & (b))
    \#define FLAG_COMBINE(a, b) ((a) \| (b))
    \#define REMOVE_FLAG(a, b)  ((a) &= ~(b))

  enums:
    enum example_flag
    {
      HAS_A = FLAG(0),
      HAS_B = FLAG(1),
      HAS_C = FLAG(2)
    };
    example_flag a = HAS_A \| HAS_B \| HAS_C;
    REMOVE_FLAG(a, HAS_B);
    if (HAS_FLAG(a, HAS_A)) { printf("has a");}
    if (HAS_FLAG(a, HAS_B)) { printf("has b");}
    if (HAS_FLAG(a, HAS_C)) { printf("has c");}
      -> has a
      -> has c
#

macros:

#
|c|C|
|inline|function|
|always_inline|__forceinline|
  inlining is a way to define a function where
  when called, the compiler doesnt tell the cpu
  to jump to the location in memory where the 
  instructions for that function are, but rather
  simply always puts all contents of the function 
  directly where it is called
  inline functions forego having to load a part of
  the programs instructions, that could be anywhere 
  in the programs machine code, which means the cache
  of the cpu might have to be completely overwritten
  rather than loading the next instructions which are
  automatically loaded in the cache, this is slow. 
  so instead of jumping between memory, just putting 
  smaller functions directly where they are called is 
  faster, but increases the overall size of the executable.

  ~ in short if you have small functions you call a lot
  $~$  it might be worth inlining them$$

  ~ inlining is actually just forcing it, the compiler 
  $~$  already inlines to optimize$$

  ~ different compilers have different ways to inline
  $~$  __forceinline is used by msvc, microsofts c/c++ compiler
    static inline __atribute  ((always_inline)) by most others$$


  example:
    in file.h
    \#if defined(_MSC_VER)
      \#define INLINE __forceinline
    \#else
      \#define INLINE static inline __attribute((always_inline))
    \#endif
  
    INLINE int inline_func(int a)
    {
      int rtn = a + 20;
      if (rtn > 50) { rtn -= 12; }
      return rtn;
    }

    in file.c
    \#include "file.h"
    void func()
    {
      int a = inline_func();
    }

  $GREEN$difference$$:
    simplified visualization of difference 
    between normal/inline functions

    INLINE int inline_add(int a, int b) { return a + b; }
    
    int normal_add(int a, int b) { return a + b; } 
    void func()
    {
      int a0 = normal_add(1, 2);
      int a1 = inline_add(1, 2);
    }

    roughly what the compiler does:
    void func()
    {
      int a0 = normal_add(1, 2);
      int a1 = a + b;
    }

#
|c|C|
|stringify|
|operator|preprocessor|macro|basics|
|to-string|to_string|\#|
  and \\# to macro arg to stringify it
  example:
    \#define TO_STR(arg)  (\\#arg)
    int var = 0;
    printf("%s: %d\n", TO_STR(var), var);
      -> var: 0
    \#define P_INT(a) printf("%s: %d\n", \\#a, a)
    P_INT(var);
      -> var: 0
#
|c|C|
|token-pasting|pasting|
|operator|preprocessor|macro|basics|
|combine|combine-macros|token|\#\#|\#|
  using the \\#\\# operator in macros
  you can expand an argument or macro and
  combine it with other text
  ~ using this operator prevents tokens 
  $~$  that are macros to expand $$
  $~$  making a pasting macro prevents this $$

  example:
    \#define TOKEN_PASTING(a, b)  a\\#\\#b
    TOKEN_PASTING(hello, world);
    -> helloworld
    
    \#define ARRAY(type, name, len) \
        type name[len];             \
        int name\\#\\#_len = len;
    ARRAY(int, arr, 10);
    -> int arr[10];
    -> int arr_len = 10;

    \#define PASTE(a, b, c, d) a\\#\\#b\\#\\#c\\#\\#d
    int PASTE(start, _mid, dle, _end) = 10;
    -> int start_middle_end = 10;

    // because \\#\\# doesnt expand macros
    \#define _I    int
    \#define PASTE(a, b)      a\\#\\#b
    \#define PASTE_2(a, b)    PASTE(a, b)
    \#define PASTE_3(a, b, c) PASTE_2(PASTE_2(a, b), c)
    
    int PASTE_3(start, _middle_, end) = 10;
    printf("%s\n", \\#PASTE_3(start, _middle_, end));
    -> start_middle_end
    
    int PASTE_3(_I, _middle_, end) = 10;
    printf("%s\n", \\#PASTE_3(_I, _middle_, end));
    ->int_middle_end
    // would be _I_middle_end otherwise
#
|__VA_ARGS__|
|variadic_arguments|variadic|preprocessor|macro|basics|
  the macro __VA_ARGS__ is used when creating variadic macros
  which means macros that variable amount of arguments
  it is the arguments themself, and should only directly be
  passed to a variadic function

  example:
    \#define PF(...)    printf(__VA_ARGS__)
    PF("hello\n");
    PF("int: %d\n", 12);
    PF("%s %s %s\n" "multiple", "args", "given");
    -> hello
    -> int: 12
    -> multiple args given
#
|__VA_OPTS__|__VA_ARGS__|
|variadic_arguments|variadic|preprocessor|macro|basics|
|FOR_EACH|FOR_EACH()|
  __VA_OPT__(x) lets you access a specific variable in __VA_ARGS__

  example: 
    // taken from: https://www.scs.stanford.edu/~dm/blog/va-opt.html
    \#define PARENS ()
    \#define EXPAND(...)  EXPAND4(EXPAND4(EXPAND4(EXPAND4(__VA_ARGS__))))
    \#define EXPAND4(...) EXPAND3(EXPAND3(EXPAND3(EXPAND3(__VA_ARGS__))))
    \#define EXPAND3(...) EXPAND2(EXPAND2(EXPAND2(EXPAND2(__VA_ARGS__))))
    \#define EXPAND2(...) EXPAND1(EXPAND1(EXPAND1(EXPAND1(__VA_ARGS__))))
    \#define EXPAND1(...) __VA_ARGS__
    // @DOC: execute macro for every var in __VA_ARGS__
    \#define FOR_EACH(macro, ...)                                    \
    \  __VA_OPT__(EXPAND(FOR_EACH_HELPER(macro, __VA_ARGS__)))
    \#define FOR_EACH_HELPER(macro, a1, ...)                         \
    \  macro(a1)                                                     \
    \  __VA_OPT__(FOR_EACH_AGAIN PARENS (macro, __VA_ARGS__))
    \#define FOR_EACH_AGAIN() FOR_EACH_HELPER

    enum my_enum { A, B, C };
    \#define CASE(e) case e: printf("%s\n", \#e);
    \#define SWITCH(x, ...)         \
      switch (x)                    \
      {                             \
        FOR_EACH(CASE, __VA_ARGS__) \
      }
    
    my_enum e = B;
    SWITCH(e, A, B, C)
    -> B
#
|c|C|
|defined|
|preprocessor|macro|basics|\#|
|&&|and|or|And|Or|AND|OR|
  turns a macro into a suitable condition for \\#if, \\#elif

  example:
    \#define A
    \#if    defined(A)
      printf("A");
    \#elif  defined(B)
      printf("B");
    \#elif !defined(B)
      printf("not B");
    \#elif defined(A) && defined(B)
      printf("A and B");
    \#elif defined(A) || defined(B)
      printf("A or B");
    \#endif
    -> A
    -> not B
#
|c|C|
|define|
|preprocessor|macro|basics|\#|
    the define preprocessor registeres 
    a piece of code under a name
    alternatively a macro can also just 
    be defined to check if its defined using \\#ifdef
    ~ use '\' to make multiline macros, no whitespace after '\'
    ~ wrapping args in parenthesis makes it safer 
    example:
      \#define HELLO
      \#define NAME   "karl"
      \#define NUMBER 34 * 67
      \#define ADD(a, b) ((a) + (b))
      \#define WARNING()      \
        printf("[!!!]");      \
        printf(" warning\n")

      printf("%s\n", NAME);
      printf("%d\n", NUMBER);
      printf("%d\n", ADD(30, 70));
      WARNING();
      \#ifdef HELLO
        printf("hello is defined\n");
      \#endif
        -> karl
        -> 2278 
        -> 100
        -> [!!!] warning
        -> hello is defined
#
|c|C|
|undef|
|undefine|preprocessor|macro|basics|\#|
  the undef preprocessor undefines a previously defined macro
  example:
    \#define A
    \#ifdef A
      printf("A");
    \#endif
    \#undef A
    \#ifdef A
      printf("A again");
    \#endif
    -> A
#
|c|C|
|if|
|endif|preprocessor|macro|basics|\#|
  check a condition at compile time and include a piece of code or not
  ! has to be terminated with one of \#endif, \#else or \#elif
  
  example:
    \#if 0 == 0
    printf("0 == 0");
    \#endif
    \#if 0 == 1
    printf("0 == 1");
    \#endif
      -> 0 == 0
#
|c|C|
|else|
|endif|preprocessor|macro|basics|\#|
  used with the \\#if, \\#elif, \\#ifdef preprocessors
  
  example:
    \#if 0 == 0
    printf("0 == 0");
    \#else
    printf("0 != 0");
    \#endif
      -> 0 == 0
#
|c|C|
|elif|
|else|endif|preprocessor|macro|basics|\#|
  used with the \\#if, \\#else, \\#ifdef preprocessors

  example:
    \#if 0 == 0
    printf("0 == 0");
    \#elif 0 == 1
    printf("0 == 1");
    \#endif
      -> 0 == 0
#
|c|C|
|ifdef|
|endif|preprocessor|macro|basics|\#|
  the ifdef preprocessor ex/includes a part of code
  depending on if the given macro is defined

  example:
    \#ifdef A
      printf("A0");
    \#endif
    \#define A
    \#ifdef A
      printf("A1");
    \#endif
    -> A1
#
|c|C|
|ifndef|
|endif|preprocessor|macro|basics|\#|
  the ifndef preprocessor ex/includes a part of code
  depending on if the given macro is not defined

  example:
    \#ifndef A
      printf("A0");
    \#endif
    \#define A
    \#ifndef A
      printf("A1");
    \#endif
    -> A0
#
|c|C|
|error|
|print|preprocessor|macro|basics|\#|
  the error preprocessor error prints an error to the stderr

  example:
    \#error "this is an error"

    \#undef MACRO
    \#ifndef MACRO
      \#error "MACRO isnt defined"
    \#endif
     
     -> this is an error
     -> MACRO isnt defined
#
|c|C|
|pragma|
|preprocessor|macro|basics|
|gcc|ignore-warning|ignore|warning|\#|
|GCC|diagnostic|push|ignored|pop|
  the pragma preprocessor issues commands to the compiler,
  therefore the commands may vary from compiler to compiler

  example:
    // this makes gcc ignore the specified in "-W..."
    // until diagnostic pop is called
    // in this example were including a header that uses 
    // pragmas not used by gcc, so we ignore the error
    // messages this would normally generate
    // at least when comopiling with "-Wall", 
    // aka. all warnings
    \#pragma GCC diagnostic push
    \#pragma GCC diagnostic ignored "-Wunknown-pragmas"
    \#include "header_with_non_gcc_pragmas.h"
    \#pragma GCC diagnostic pop
#

flow control:

#
|c|C|
|goto|label|Label|
|flow-control|basics|
  the goto statement jumps to a label
  a label is a defined / named position in the code
  a label is just a name followed by a :
  ! labels and goto statement are generally regarded
  $!$   as unsafe and should be avoided$$
  $!$   as they complicate following the flow of execution$$

  example: 
    if (str \!= NULL)
    { goto label_print; }
    else
    { goto label_exit; }

    label_print:;
    printf("%s\n", str);
    label_exit:;
    return;

  ?< https://en.cppreference.com/w/c/language/goto >?
#
|c|C|
|if|
|flow-control|basics|
  execute a piece of code based on a condition

  example:
    if (0 == 0)  { printf("0 == 0"); }
    if (true)    { printf("true"); }
    if (false)   { printf("false"); }
    bool boolean = true;
    if (boolean) { printf("boolean"); }
    boolean = false;
    if (boolean) { printf("boolean"); }
      -> 0 == 0
      -> true
      -> boolean
#
|c|C|
|else|else-if|else-if|
|flow-control|basics|
  after a if or else if statement this executes
  a block of code if the previous statement didnt
  else if executes the block of code under those 
  circumstances as well as checking the given condition

  example:
    if (0 == 0) { printf("0 if");   }
    else        { printf("0 else"); }
    
    if (0 == 1) { printf("1 if");   }
    else        { printf("1 else"); }

    if (0 == 1)    { printf("2 if");      }
    else if (0==0) { printf("2 else if"); }
    else           { printf("2 else");    }
    
    int c = 2;
    if (c == 0)      { printf("c == 0"); }
    else if (c == 1) { printf("c == 1"); }
    else if (c == 2) { printf("c == 2"); }
    else if (c == 3) { printf("c == 3"); }
    else             { printf("c == ?"); }
    -> 0 if
    -> 1 else
    -> 2 else if
    -> c == 2
#
|c|C|
|conditional|ternary|
|operator|
|flow-control|basics|
  single line statement evaluating to a value
  that works like a if / if else / else chain
  
  $GREEN$structure$$:
    condition ? if true : if false
    can be chained
    condition_a ? if true : condition_b ? if true : ...

  example:
    // eval to bool
    bool a = 0 == 0 ? true : false; // 0 is 0 so a is true
    if (a ? false : true) {}
    
    // eval to other value
    int num  = 3;
    int num2 = num == 0 ? 0 : num == 1 ? 1 : 
               num == 2 ? 2 : num == 3 : 3;    // num2 is also 3

    float speed = 10.0f;
    pow(2, speed > 8.0f ? 4 : 6);
#
|c|C|
|while|while-loop|
|flow-control|loop|basics|
|break|continue|
  repeatedly executes a block of code
  while the given condition is true
  ~ use the break command to exit the loop
  ~ use continue to skip the rest of the current loops run
  ~ and continue at the start of the lopo
  ! if the condition never turns false
  ! the program will be stuck in the loop

  example:
    // for loop using while loop
    int count = 10;
    while (count <= 0) { printf("%d, ", count); count--; }
    -> 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0,

    // search string text for '%'
    bool found = false;
    int  pos   = 0;
    while (found = false && pos < text_length)
    { if (text[pos] == '%') { found = true; } pos++; }
    if (found) { printf("found %% at %d\n", pos); }
    -> found % at XXX

    // infinite loop, with break
    int end = 222;
    int pos = 0;
    while (true)
    { 
      if (pos >= end) { break;} 
      pos++;
    }
    printf("pos: %d\n", pos);
    -> pos: 221

#
|c|C|
|do-while|do|while|do-while-loop|
|flow-control|basics|
  same as while loop, only that this loop executes the block
  once before checking the condition, assuring it always gets 
  executed least once
  see \|while\| for more explanation
  ~ break exits out of the loop
  ~ continue jumps to the start of the loop

  example:
    int a = 0;
    do
    {
      a++;
    }
    while (false);
    printf("a: %d\n", a);
    -> a: 1
#
|c|C|
|for|for-loop|
|flow-control|loop|basics|
  the for loop executes a block of code 
  as long as the middle condition is true
  it also initializes a local variable
  and allows you to execute a line of code 
  at the end of each loop
  this loop cant do anything the while loop cant do
  but its purpose is often easier to understand
  thanks to the for loops's structure
  ~ its common to call the for loops variable i
  ~ for iterator, j, k, follow if you have a nested loop
  ~ break exits out of the loop
  ~ continue jumps to the start of the loop

  $GREEN$structure$$:
    for (INITIALIZE_VAR; CONDITION; EXECUTES_AT_END_OF_LOOP)
    { BLOCK_OF_CODE }
    ~ equivalent to:
    INITIALIZE_VAR
    while (CONDITION)
    {
      BLOCK_OF_CODE
      EXECUTES_AT_END_OF_LOOP
    }
  example: 
    for (int i = 0; i < 10; ++i)
    { printf("%d, ", i); }
    -> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
    
    int arr[3] = { 4, 5, 6 };
    int arr_len = 3;
    for (int i = 0; i < arr_len; ++i)
    { printf("%d, ", arr[i]); }
    -> 4, 5, 6,
#
|c|C|
|switch|case|default|
|flow-control|loop|basics|
  the switch statement checks a input variable 
  agaist multiple cases and executes the code 
  if cases are met by the variable

  ~ break exits out of the switch statement
  ~ default case must be last, is optional and
  $~$  only gets executed if no other case was $$
  ~ without a break the statement falls through to 
  $~$  the one below$$

  example: 
    int c = 1;
    
    switch (c)
    {
      case 0  :
        printf("c is 0");
        break;
      case 1  :
      case 11 :
        printf("c has 1");
      case 2  :
      case 22 :
        printf("c has 2");
        break;

      default :
      printf("none of the above");
    }
    -> c has 1
#

functions:

#
|c|C|
|scope|Scope|
  a scope is a block of code f.e.
  a function or an if statement

  example:
    void function()
    { // function scope start
      
      //declared in function scope
      // only accessible in function scope
      int a = 0;  
      
      if ()
      { // if scope start

        //declared in if scope
        // only accessible in if scope
        int b = 0;
      
      } // if scope end
    
    } // function scope end
#
|c|C|
|function|Function|func|Func|
  a function is a specified block of code
  that can be invoked from other code
  function declarations are usually put in
  header files, .h, but can also be put at the 
  top of .c files limiting access to that function 
  to that .c file

  <type> <name>()
  <type> <name>(<arg-type> <arg-name>)

  example:
    $_$in app.h$$
    // declare in header for global access
    void funtion_a();
    int  function_b(int arg);
    void function_c(int arg0, int arg1);

    $_$in app.c:$$
    void function_d();  // declaration in .c file
    
    int main(void)
    {
      function_a();
      int a = function_b(12);
      function_c(2, 42);
      function_d();
    }
    void function_d()
    {
      // do something
    }
#
|c|C|
|main|
|entry|entrypoint|function|
|commandline|command-line|arguments|
|command-line-arguments|cmd|terminal|
|argc|argv|basics|
  the function main() is the entrypoint of any c program
  it gets called when the program is started and the 
  program exits/ends when the function returns
  it gets passed an array of the commandline arguments
  see $|$EXIT_SUCCESS$$ and $|$EXIT_FAILURE$$
  argc: length of char* in argv
  argv: array of char* containing commandline arguments
  argv[0] is the name of the program
  ~ mains arguments are optional
  ~ main() is usually put in main.c, but this isnt required

  example:
    $_$call in terminal:$$
    > app apple pineapple 
    
    int main(int argc, char** argv)
    {
      // print all commandline arguments
      for (int i = 0; i < argc; i++)
      {
        printf("arg nr: %d: %s\n", argv[i]);
      }
      -> arg nr 0: app
      -> arg nr 1: apple
      -> arg nr 2: pineapple
      
      // return with error
      if (error_occured)
      {
        return 0;
      }

      // return succefully
      return 1;
    }
    
    // same thing
    return 1;
    return EXIT_SUCCESS;

    // same thing
    return 0;
    return EXIT_FAILURE;

    // same thing
    int main(int argc, char** argv)
    int main(int argc, char* argv[])

    // ommit the commandline args
    int main(void)  // preferred because verbose
    int main()
#

entry-point:

#
|c|C|
|entry|entry-point|main|basics|
|command-line|command-line-arguments|arguments|
|EXIT_SUCCESS|EXIT_FAILURE|
  the entry point function is the function that gets 
  automatically executed at the start of the program
  so it is where all your logic should start
  the returned int indicates if the program ran 
  successfully or not, uses the $G$macros$$
  the entry point function is always called 'main'
  it can be type int main(), int main(void) or $$
  int main(int, char**) / int main(int, char* argv[]) $$
  both are the same, an array of char* / string

  $G$macros$$:
    EXIT_SUCCESS: 0,     can be returned in main() 
    EXIT_FAILURE: non 0, can be returned in main() 

  example:
    int main()
    {
      ...
      return EXIT_SUCCESS;
    }
    
    // if invoked in terminal, i.e >app arg1 arg2 arg3
    int main(int argc, char** argv)
    {
      // standard names
      // argc: argument count
      // argv: argumnet value

      // print all command line args
      for (int i = 0; i < argc; ++i)
      {
        printf("argument[%d]: %s\n", argc, argv[i]);
      }
      -> arg1
      -> arg2
      -> arg3

      return 0; // same as EXIT_SUCCESS
    }

    // exit failure if file not found
    int main()
    {
      FILE* f = fopen("file.txt", "r");
      if (f == NULL)
      {
        return EXIT_FAILURE;
      }
      
      ...
  
      return EXIT_SUCCESS;
    }

#

